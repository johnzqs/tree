<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å„¿å­çš„åœ£è¯æ ‘ - 3D äº’åŠ¨ä½“éªŒ</title>
    <!-- å¼•å…¥å­—ä½“ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Sans+SC:wght@300;500&display=swap" rel="stylesheet">
    
    <style>
        /* åŸºç¡€æ ·å¼ä¸é‡ç½® */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Cinzel', 'Noto Sans SC', serif;
            color: #d4af37; /* é¦™æ§Ÿé‡‘ */
            user-select: none;
        }

        /* å¯åŠ¨é¡µ */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #050505 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }

        h1 {
            font-size: 3rem;
            letter-spacing: 5px;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            text-align: center;
        }

        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
        }

        .btn {
            border: 1px solid #d4af37;
            color: #d4af37;
            background-color: transparent;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }

        .btn:hover {
            background-color: rgba(212, 175, 55, 0.1);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        /* éšè—åŸå§‹æ–‡ä»¶è¾“å…¥æ¡† */
        input[type=file] {
            display: none;
        }

        #file-name {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #888;
            min-height: 20px;
        }
        
        #manual-upload-section {
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½å¤±è´¥æ—¶æ˜¾ç¤º */
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            border: 1px dashed #d4af37;
            padding: 20px;
            border-radius: 10px;
            background: rgba(212, 175, 55, 0.05);
            max-width: 600px;
        }

        .warning-text {
            color: #ffcc00;
            font-size: 0.9rem;
            margin-bottom: 15px;
            width: 100%;
            line-height: 1.6;
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #d4af37;
            box-sizing: border-box;
        }
        
        .warning-text strong {
            color: #fff;
            font-size: 1rem;
            display: block;
            margin-bottom: 8px;
        }

        /* ä¸»UIå±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
            display: none; /* å¯åŠ¨åæ˜¾ç¤º */
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #d4af37;
            color: #d4af37;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
        }
        
        .control-btn:active {
            background: #d4af37;
            color: #000;
        }

        #status-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 0.8rem;
            color: rgba(212, 175, 55, 0.7);
            line-height: 1.5;
        }

        #music-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            cursor: pointer;
            font-size: 1.5rem;
            opacity: 0.7;
        }

        #gesture-guide {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 0 2px black;
        }
        
        #loading-text {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #666;
        }

        #photo-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.5rem;
            display: none;
            pointer-events: none;
            border: 2px solid #ff9900;
        }

        /* è§†é¢‘å…ƒç´ ç”¨äº MediaPipe (éšè—) */
        .input_video {
            display: none;
        }
    </style>
    
    <!-- MediaPipe ä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- å¯åŠ¨ç•Œé¢ -->
    <div id="start-screen">
        <h1>SON'S CHRISTMAS TREE</h1>
        <div class="upload-btn-wrapper">
            <!-- è‡ªåŠ¨åŠ è½½çŠ¶æ€ -->
            <div id="auto-load-msg" style="color: #d4af37; margin-bottom: 10px;">æ­£åœ¨åˆå§‹åŒ–...</div>
            
            <!-- æ‰‹åŠ¨ä¸Šä¼ å¤‡ç”¨æ–¹æ¡ˆ (é»˜è®¤éšè—ï¼Œè‡ªåŠ¨åŠ è½½å¤±è´¥æ—¶æ˜¾ç¤º) -->
            <div id="manual-upload-section">
                <div class="warning-text">
                    <strong>âš ï¸ æœªæ£€æµ‹åˆ°è‡ªåŠ¨ç…§ç‰‡åŠ è½½</strong>
                    <br>
                    ç”±äºæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œæ— æ³•ç›´æ¥è¯»å–ç¡¬ç›˜ã€‚<br>
                    è¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼Œè¿›å…¥ <strong>photos</strong> æ–‡ä»¶å¤¹ï¼Œ<span style="color: #fff; text-decoration: underline;">å…¨é€‰æ‰€æœ‰ç…§ç‰‡ (Ctrl+A)</span> å¹¶æ‰“å¼€ã€‚
                </div>
                <label for="manual-photo-upload" class="btn">ğŸ“‚ ç‚¹å‡»æ‰‹åŠ¨é€‰æ‹©ç…§ç‰‡</label>
                <input type="file" id="manual-photo-upload" accept="image/*" multiple />
            </div>
        </div>
        <div id="file-name"></div>
        <div style="height: 20px;"></div>
        <button class="btn" id="enter-btn">è¿›å…¥ä½“éªŒ</button>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ– 3D å¼•æ“ä¸æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>

    <!-- ä¸»ç•Œé¢ UI -->
    <div id="ui-layer">
        <div id="status-panel">
            çŠ¶æ€: <span id="mode-text">åœ£è¯æ ‘</span><br>
            æ‰‹åŠ¿: <span id="gesture-text">æ£€æµ‹ä¸­...</span><br>
            ğŸ“¸ ç…§ç‰‡æ•°: <span id="photo-count-display">0</span>
        </div>
        
        <div id="music-toggle">ğŸµ</div>

        <div id="gesture-guide">
            å¼ æ‰‹: åœ£è¯æ ‘ | æ¡æ‹³: å˜çˆ±å¿ƒ | æåˆ: çœ‹ç…§ç‰‡ | æŒ¥æ‰‹: æ—‹è½¬
        </div>

        <div id="controls">
            <button class="control-btn" id="light-up-btn">âœ¨ ç‚¹äº®ä»ªå¼ âœ¨</button>
        </div>
        
        <div id="photo-warning">è¯·å…ˆåŠ è½½ç…§ç‰‡ï¼</div>
    </div>

    <!-- MediaPipe è§†é¢‘æº -->
    <video class="input_video"></video>

    <!-- éŸ³é¢‘ (è¯»å–æœ¬åœ° music.mp3) -->
    <audio id="bgm" loop>
        <source src="./music.mp3" type="audio/mp3">
        <source src="./music.ogg" type="audio/ogg">
    </audio>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer, controls;
        let particles, particleGeo, material;
        let starMesh, textMesh, photoMesh;
        let santaGroup; // åœ£è¯è€äººç»„
        let rippleSystem; // åº•éƒ¨å…‰ç¯
        let fireworks = [];
        
        // å¸¸é‡ï¼šæ ‘çš„å‚æ•°
        const TREE_HEIGHT = 18.0; 
        const TREE_BASE_RADIUS = 7.5; 
        const HEART_CENTER_Y = 9.0; // çˆ±å¿ƒä¸­å¿ƒé«˜åº¦
        
        // çŠ¶æ€ç®¡ç†
        const state = {
            morphTarget: 'tree', // 'tree' or 'heart'
            morphFactor: 0,      // 0 = tree, 1 = heart
            isLit: false,        // æ˜¯å¦ç‚¹äº®
            lightProgress: 0,    // ç‚¹äº®è¿›åº¦ 0-1
            isPinching: false,   // æ˜¯å¦æåˆ
            photoState: 'hidden', // hidden, in, visible, out
            photoAnimProgress: 0,
            photoStartPos: new THREE.Vector3(),
            photoEndPos: new THREE.Vector3(),
            photoFinalScale: new THREE.Vector3(),
            uploadedTextures: [], // ç”¨æˆ·ä¸Šä¼ çš„ç…§ç‰‡çº¹ç†
            currentTextureIndex: 0,
            rotationSpeed: 0.002, // åŸºç¡€è‡ªè½¬é€Ÿåº¦
        };

        // é¢œè‰²é…ç½®
        const COLORS = [
            new THREE.Color('#ff0000'), // çº¢
            new THREE.Color('#00ff00'), // ç»¿
            new THREE.Color('#0000ff'), // è“
            new THREE.Color('#800080'), // ç´«
            new THREE.Color('#d4af37'), // é‡‘
            new THREE.Color('#ffffff'), // ç™½
            new THREE.Color('#00ffff')  // é’
        ];

        // --- åˆå§‹åŒ–å…¥å£ ---
        
        window.onload = () => {
            initThree();
            setupMediaPipe();
            setupUI();
            animate();
        };

        // --- 1. Three.js åœºæ™¯æ„å»º ---

        function initThree() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // æ‘„åƒæœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 9, 35);
            camera.lookAt(0, 9, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // åå¤„ç† (Bloom)
            const renderScene = new RenderPass(scene, camera);

            // Bloom å‚æ•°
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.9; 
            bloomPass.strength = 0.8;
            bloomPass.radius = 0.5;

            const outputPass = new OutputPass();

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);

            // æ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2; // ç¦æ­¢é’»åœ°
            controls.target.set(0, 9, 0); 

            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // ç¨å¾®è°ƒäº®ä¸€ç‚¹
            scene.add(ambientLight);

            // å¹³è¡Œå…‰ (ç…§äº®é©¯é¹¿)
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            // åœºæ™¯å…ƒç´ ç”Ÿæˆ
            createParticles();
            createRipples();
            createStar();
            createBillboardText();
            createPhotoFrame();
            createSanta(); // åˆ›å»ºåœ£è¯è€äºº
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. å‡ ä½•ä½“ä¸ç²’å­ç³»ç»Ÿé€»è¾‘ ---

        function createParticles() {
            const spiralCount = 1800;
            const fillerCount = 3500;
            
            particleGeo = new THREE.BufferGeometry();
            
            const positions = [];      
            const treePositions = [];  
            const heartPositions = []; 
            const colors = [];
            const sizes = [];
            const randomness = [];     

            // 1. èºæ—‹å…‰å¸¦ç²’å­
            for (let i = 0; i < spiralCount; i++) {
                const h = Math.random() * TREE_HEIGHT;
                const angle = h * 2.5 + Math.random() * 0.5; 
                const r = (TREE_HEIGHT - h) * (TREE_BASE_RADIUS / TREE_HEIGHT) + 0.5; 
                
                const tx = Math.cos(angle) * r;
                const tz = Math.sin(angle) * r;
                const ty = h;
                addParticle(tx, ty, tz, treePositions, heartPositions, positions, colors, sizes, randomness, true);
            }

            // 2. å†…éƒ¨å¡«å……ç²’å­
            for (let i = 0; i < fillerCount; i++) {
                const h = Math.random() * TREE_HEIGHT;
                const maxR = (TREE_HEIGHT - h) * (TREE_BASE_RADIUS / TREE_HEIGHT) + 0.5;
                const r = maxR * Math.sqrt(Math.random()) * 0.9; 
                const angle = Math.random() * Math.PI * 2;
                const tx = Math.cos(angle) * r;
                const tz = Math.sin(angle) * r;
                const ty = h;
                addParticle(tx, ty, tz, treePositions, heartPositions, positions, colors, sizes, randomness, false);
            }

            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.setAttribute('targetTree', new THREE.Float32BufferAttribute(treePositions, 3));
            particleGeo.setAttribute('targetHeart', new THREE.Float32BufferAttribute(heartPositions, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            particleGeo.setAttribute('randomness', new THREE.Float32BufferAttribute(randomness, 3));

            // æè´¨
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMorphFactor: { value: 0 },
                    uLitHeight: { value: -1.0 },
                    pointTexture: { value: createCircleTexture() }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMorphFactor;
                    uniform float uLitHeight;
                    
                    attribute vec3 targetTree;
                    attribute vec3 targetHeart;
                    attribute vec3 color;
                    attribute float size;
                    attribute vec3 randomness;

                    varying vec3 vColor;

                    void main() {
                        vec3 pos = mix(targetTree, targetHeart, uMorphFactor);

                        if (uMorphFactor < 0.9) {
                            float breath = sin(uTime * 2.0 + randomness.x * 10.0) * 0.05 * (1.0 - uMorphFactor);
                            pos += normalize(pos) * breath;
                        } else {
                            pos.x += sin(uTime + randomness.y * 10.0) * 0.02;
                            pos.y += cos(uTime + randomness.z * 10.0) * 0.02;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (1800.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;

                        vColor = color;

                        float brightness = 1.0;
                        if (uMorphFactor < 0.1) {
                            if (pos.y > uLitHeight) {
                                brightness = 0.8; 
                            } else {
                                brightness = 1.8; 
                            }
                        } else {
                            brightness = 1.8; 
                        }
                        
                        vColor *= brightness;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                        gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                        if (gl_FragColor.a < 0.3) discard;
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(particleGeo, shaderMaterial);
            scene.add(particles);
        }

        function addParticle(tx, ty, tz, treeArr, heartArr, posArr, colArr, sizeArr, rndArr, isSpiral) {
            treeArr.push(tx, ty, tz);
            posArr.push(tx, ty, tz);

            const scale = 0.35; 
            const t = Math.random() * Math.PI * 2;
            let px = 16 * Math.pow(Math.sin(t), 3);
            let py = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            let pz = (Math.random() - 0.5) * 6 * (1 - Math.abs(py)/15);

            if (!isSpiral) {
                const volScale = Math.cbrt(Math.random()); 
                px *= volScale;
                py *= volScale;
                pz *= volScale;
            }

            // çˆ±å¿ƒä½ç½®ä¸­å¿ƒ (y ~ 9)
            heartArr.push(px * scale, py * scale + HEART_CENTER_Y, pz * scale);

            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            colArr.push(color.r, color.g, color.b);

            const baseSize = isSpiral ? 0.08 : 0.06;
            sizeArr.push(Math.random() * 0.05 + baseSize);
            rndArr.push(Math.random(), Math.random(), Math.random());
        }

        function createRipples() {
            const count = 300;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const params = []; 

            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.02 + Math.random() * 0.03; 
                const r = Math.random() * 10; 
                
                positions[i*3] = Math.cos(angle) * r;
                positions[i*3+1] = 0.1; 
                positions[i*3+2] = Math.sin(angle) * r;
                
                params.push({ angle, speed, r });
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                color: 0xd4af37, 
                size: 0.15,
                transparent: true,
                opacity: 0.6,
                map: createCircleTexture(),
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            rippleSystem = new THREE.Points(geo, mat);
            rippleSystem.userData = { params }; 
            scene.add(rippleSystem);
        }

        function createStar() {
            const shape = new THREE.Shape();
            const points = 5;
            const outerRadius = 0.6; 
            const innerRadius = 0.3; 
            for (let i = 0; i < points * 2; i++) {
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const a = (i / (points * 2)) * Math.PI * 2;
                const adjustedAngle = a - Math.PI / 2;
                const x = Math.cos(adjustedAngle) * r;
                const y = Math.sin(adjustedAngle) * r;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 });
            
            geometry.center();

            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                roughness: 0.3, 
                metalness: 0.8, 
                emissive: 0xffaa00, 
                emissiveIntensity: 0.8 
            });
            starMesh = new THREE.Mesh(geometry, material);
            starMesh.position.set(0, 18.2, 0);
            scene.add(starMesh);
        }

        function createBillboardText() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 100px "Cinzel"';
            ctx.fillStyle = '#d4af37';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.fillText('MERRY CHRISTMAS', canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending 
            });
            textMesh = new THREE.Sprite(material);
            textMesh.position.set(0, 19.5, 0);
            textMesh.scale.set(6, 1.5, 1);
            textMesh.visible = false;
            scene.add(textMesh);
        }

        function createPhotoFrame() {
            const geometry = new THREE.PlaneGeometry(1, 1);
            const material = new THREE.MeshBasicMaterial({
                color: 0xcccccc, side: THREE.DoubleSide, toneMapped: false, transparent: true, opacity: 0
            });
            photoMesh = new THREE.Mesh(geometry, material);
            photoMesh.visible = false;
            scene.add(photoMesh);
        }

        // --- åˆ›å»ºæ›´ç²¾ç»†çš„åœ£è¯è€äººå’Œé©¯é¹¿ ---
        function createSanta() {
            santaGroup = new THREE.Group();
            
            // æè´¨åº“
            const matRed = new THREE.MeshStandardMaterial({ color: 0xc40000, roughness: 0.3 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            const matFace = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.5 });
            const matGold = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.6, roughness: 0.3 });
            
            // ä¿®å¤ï¼šæäº®é©¯é¹¿æè´¨é¢œè‰²ï¼Œå¹¶å¢åŠ  emissive è‡ªå‘å…‰ï¼Œç¡®ä¿åœ¨é»‘å¤œå¯è§
            const matBrown = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513, // éè¤è‰² (æ›´äº®)
                roughness: 0.8,
                emissive: 0x331100, // å¾®å¼±è‡ªå‘å…‰
                emissiveIntensity: 0.2
            });
            const matDarkBrown = new THREE.MeshStandardMaterial({ 
                color: 0x3e2723, 
                roughness: 0.9,
                emissive: 0x110000,
                emissiveIntensity: 0.2
            });
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });

            // --- 1. æ„å»ºé©¯é¹¿ (Reindeer) ---
            const createDeer = (x, z) => {
                const deerGroup = new THREE.Group();
                deerGroup.position.set(x, 0, z);

                // èº«ä½“
                const bodyGeo = new THREE.BoxGeometry(0.35, 0.4, 0.7);
                const body = new THREE.Mesh(bodyGeo, matBrown);
                body.position.y = 0.6;
                deerGroup.add(body);

                // è„–å­
                const neckGeo = new THREE.BoxGeometry(0.15, 0.3, 0.2);
                const neck = new THREE.Mesh(neckGeo, matBrown);
                neck.position.set(0, 0.85, 0.25);
                neck.rotation.x = -Math.PI / 4;
                deerGroup.add(neck);

                // å¤´
                const headGeo = new THREE.BoxGeometry(0.2, 0.25, 0.35);
                const head = new THREE.Mesh(headGeo, matBrown);
                head.position.set(0, 1.05, 0.45);
                deerGroup.add(head);

                // é¼»å­
                const noseGeo = new THREE.SphereGeometry(0.06);
                const nose = new THREE.Mesh(noseGeo, new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xaa0000}));
                nose.position.set(0, 1.05, 0.65);
                deerGroup.add(nose);

                // è§’
                const antlerGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4);
                const leftAntler = new THREE.Mesh(antlerGeo, matDarkBrown);
                leftAntler.position.set(-0.1, 1.25, 0.4);
                leftAntler.rotation.z = 0.5;
                leftAntler.rotation.x = -0.5;
                deerGroup.add(leftAntler);

                const rightAntler = new THREE.Mesh(antlerGeo, matDarkBrown);
                rightAntler.position.set(0.1, 1.25, 0.4);
                rightAntler.rotation.z = -0.5;
                rightAntler.rotation.x = -0.5;
                deerGroup.add(rightAntler);

                // è…¿
                const legGeo = new THREE.BoxGeometry(0.08, 0.6, 0.08);
                const legPositions = [
                    {x: -0.12, y: 0.3, z: 0.25}, 
                    {x: 0.12, y: 0.3, z: 0.25}, 
                    {x: -0.12, y: 0.3, z: -0.25}, 
                    {x: 0.12, y: 0.3, z: -0.25}
                ];
                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, matBrown);
                    leg.position.set(pos.x, pos.y, pos.z);
                    leg.rotation.x = (Math.random() - 0.5) * 0.5;
                    deerGroup.add(leg);
                });

                return deerGroup;
            };

            santaGroup.add(createDeer(-0.4, 3.0));
            santaGroup.add(createDeer(0.4, 3.0));
            santaGroup.add(createDeer(-0.4, 4.5));
            santaGroup.add(createDeer(0.4, 4.5));

            // --- 2. æ„å»ºé›ªæ©‡ (Sleigh) ---
            const sleighGroup = new THREE.Group();
            const sleighBodyGeo = new THREE.BoxGeometry(1.0, 0.5, 1.6);
            const sleighBody = new THREE.Mesh(sleighBodyGeo, matRed);
            sleighBody.position.y = 0.5;
            sleighGroup.add(sleighBody);

            const trimGeo = new THREE.BoxGeometry(1.05, 0.1, 1.65);
            const trim = new THREE.Mesh(trimGeo, matGold);
            trim.position.y = 0.75;
            sleighGroup.add(trim);

            const runnerGeo = new THREE.BoxGeometry(0.1, 0.1, 2.2);
            const runnerL = new THREE.Mesh(runnerGeo, matGold);
            runnerL.position.set(-0.4, 0.1, 0);
            runnerL.rotation.x = -0.05; 
            const runnerR = new THREE.Mesh(runnerGeo, matGold);
            runnerR.position.set(0.4, 0.1, 0);
            runnerR.rotation.x = -0.05;
            sleighGroup.add(runnerL);
            sleighGroup.add(runnerR);

            const connectorGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const c1 = new THREE.Mesh(connectorGeo, matGold); c1.position.set(-0.4, 0.3, 0.5);
            const c2 = new THREE.Mesh(connectorGeo, matGold); c2.position.set(0.4, 0.3, 0.5);
            const c3 = new THREE.Mesh(connectorGeo, matGold); c3.position.set(-0.4, 0.3, -0.5);
            const c4 = new THREE.Mesh(connectorGeo, matGold); c4.position.set(0.4, 0.3, -0.5);
            sleighGroup.add(c1, c2, c3, c4);
            santaGroup.add(sleighGroup);

            // --- 3. æ„å»ºåœ£è¯è€äºº (Santa) ---
            const santaChar = new THREE.Group();
            santaChar.position.set(0, 0.7, -0.2);

            const torsoGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const torso = new THREE.Mesh(torsoGeo, matRed);
            torso.scale.y = 1.2;
            santaChar.add(torso);

            const buttonGeo = new THREE.SphereGeometry(0.04);
            const b1 = new THREE.Mesh(buttonGeo, matBlack); b1.position.set(0, 0.1, 0.32);
            const b2 = new THREE.Mesh(buttonGeo, matBlack); b2.position.set(0, -0.1, 0.34);
            santaChar.add(b1, b2);

            const beltGeo = new THREE.CylinderGeometry(0.36, 0.36, 0.1, 16);
            const belt = new THREE.Mesh(beltGeo, matBlack);
            belt.position.y = -0.15;
            santaChar.add(belt);

            const headGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const head = new THREE.Mesh(headGeo, matFace);
            head.position.y = 0.45;
            santaChar.add(head);

            const beardGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const beard = new THREE.Mesh(beardGeo, matWhite);
            beard.position.set(0, 0.35, 0.15);
            beard.scale.set(1, 0.8, 0.5);
            santaChar.add(beard);

            const hatGroup = new THREE.Group();
            hatGroup.position.set(0, 0.6, 0);
            const hatBrimGeo = new THREE.TorusGeometry(0.21, 0.05, 8, 20);
            const hatBrim = new THREE.Mesh(hatBrimGeo, matWhite);
            hatBrim.rotation.x = Math.PI / 2;
            hatGroup.add(hatBrim);
            const hatConeGeo = new THREE.ConeGeometry(0.2, 0.5, 16);
            const hatCone = new THREE.Mesh(hatConeGeo, matRed);
            hatCone.position.y = 0.25;
            hatCone.rotation.z = -0.2;
            hatCone.position.x = 0.05;
            hatGroup.add(hatCone);
            const hatBallGeo = new THREE.SphereGeometry(0.06);
            const hatBall = new THREE.Mesh(hatBallGeo, matWhite);
            hatBall.position.set(0.15, 0.5, 0);
            hatGroup.add(hatBall);
            santaChar.add(hatGroup);

            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.4);
            const armL = new THREE.Mesh(armGeo, matRed);
            armL.position.set(-0.35, 0.1, 0);
            armL.rotation.z = -0.5;
            armL.rotation.x = 0.5; 
            const armR = new THREE.Mesh(armGeo, matRed);
            armR.position.set(0.35, 0.1, 0);
            armR.rotation.z = 0.5;
            armR.rotation.x = 0.5;
            santaChar.add(armL, armR);

            const gloveGeo = new THREE.SphereGeometry(0.1);
            const gloveL = new THREE.Mesh(gloveGeo, matWhite);
            gloveL.position.set(0, -0.2, 0);
            armL.add(gloveL);
            const gloveR = new THREE.Mesh(gloveGeo, matWhite);
            gloveR.position.set(0, -0.2, 0);
            armR.add(gloveR);
            santaGroup.add(santaChar);

            const ropeMatSolid = new THREE.LineBasicMaterial({ color: 0xd4af37, opacity: 0.4, transparent: true });
            const ropeGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-0.3, 0.8, -0.2), new THREE.Vector3(-0.4, 0.8, 3.0), new THREE.Vector3(-0.4, 0.8, 4.5)
            ]);
            santaGroup.add(new THREE.Line(ropeGeo, ropeMatSolid));
            const ropeGeo2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0.3, 0.8, -0.2), new THREE.Vector3(0.4, 0.8, 3.0), new THREE.Vector3(0.4, 0.8, 4.5)
            ]);
            santaGroup.add(new THREE.Line(ropeGeo2, ropeMatSolid));

            santaGroup.scale.set(0.8, 0.8, 0.8);
            scene.add(santaGroup);
        }

        function updatePhotoTexture() {
            if (state.uploadedTextures.length === 0) return;
            const tex = state.uploadedTextures[state.currentTextureIndex];
            photoMesh.material.map = tex;
            photoMesh.material.needsUpdate = true;
            const image = tex.image;
            const aspect = image.width / image.height;
            const maxSize = 4.0; 
            
            if (aspect > 1) {
                photoMesh.scale.set(maxSize, maxSize / aspect, 1);
            } else {
                photoMesh.scale.set(maxSize * aspect, maxSize, 1);
            }
            state.photoFinalScale = photoMesh.scale.clone(); 
        }

        function getRandomTreePos() {
            const h = Math.random() * (TREE_HEIGHT - 2) + 1; 
            const r = (TREE_HEIGHT - h) * (TREE_BASE_RADIUS / TREE_HEIGHT) + 0.5;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const vec = new THREE.Vector3(x, h, z);
            vec.applyAxisAngle(new THREE.Vector3(0, 1, 0), particles.rotation.y);
            return vec;
        }

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function launchFirework() {
            const fwColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            const fwGeo = new THREE.BufferGeometry();
            const count = 100;
            const positions = [];
            const velocities = [];
            
            const centerX = (Math.random() - 0.5) * 80; 
            const centerY = 15 + Math.random() * 25;    
            const centerZ = -30 - Math.random() * 40;   

            for(let i=0; i<count; i++) {
                positions.push(centerX, centerY, centerZ);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.2 + Math.random() * 0.3; 
                velocities.push(Math.sin(phi) * Math.cos(theta) * speed, Math.cos(phi) * speed, Math.sin(phi) * Math.sin(theta) * speed);
            }
            fwGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const fwMat = new THREE.PointsMaterial({ color: fwColor, size: 0.5, transparent: true, opacity: 1, blending: THREE.AdditiveBlending });
            const fwSystem = new THREE.Points(fwGeo, fwMat);
            scene.add(fwSystem);
            fireworks.push({ mesh: fwSystem, velocities: velocities, age: 0, life: 80 }); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            // 1. Morphing Logic
            const targetFactor = state.morphTarget === 'heart' ? 1.0 : 0.0;
            state.morphFactor += (targetFactor - state.morphFactor) * 0.05;
            
            // Star and Text Animation: Fall into heart center (fade scale and move position)
            if (starMesh) {
                // æ ‘é¡¶ä½ç½®: 18.2, å¿ƒå½¢ä¸­å¿ƒ: 9.0
                starMesh.position.y = THREE.MathUtils.lerp(18.2, HEART_CENTER_Y, state.morphFactor);
                // å˜æˆçˆ±å¿ƒæ—¶ç¼©å°åˆ°æ¶ˆå¤± (Scale 1 -> 0)
                const s = 1.0 - state.morphFactor; 
                starMesh.scale.setScalar(s > 0 ? s : 0);
                starMesh.rotation.y = particles ? particles.rotation.y : 0;
            }
            
            if (textMesh) {
                // æ–‡å­—ä½ç½®: 19.5 -> 9.0
                textMesh.position.y = THREE.MathUtils.lerp(19.5, HEART_CENTER_Y, state.morphFactor);
                // ç¼©å°æ–‡å­—
                const s = 1.0 - state.morphFactor;
                textMesh.scale.set(6 * s, 1.5 * s, 1); 
            }

            if (particles) {
                particles.material.uniforms.uTime.value = time;
                particles.material.uniforms.uMorphFactor.value = state.morphFactor;
                
                // ç‚¹ç¯é€»è¾‘
                if (state.isLit && state.morphTarget === 'tree' && state.lightProgress < 1.0) {
                    state.lightProgress += 0.005;
                    particles.material.uniforms.uLitHeight.value = state.lightProgress * (TREE_HEIGHT + 2); 
                    if (state.lightProgress >= 0.95 && !textMesh.visible) {
                        textMesh.visible = true;
                        for(let i=0; i<5; i++) setTimeout(launchFirework, i*500);
                    }
                } else if (!state.isLit) {
                     particles.material.uniforms.uLitHeight.value = -1;
                }

                // æ—‹è½¬é€»è¾‘
                if (state.morphFactor < 0.5) {
                    particles.rotation.y += state.rotationSpeed;
                    
                    // è‡ªåŠ¨éšæœºçƒŸèŠ±
                    if (!state.isPinching && Math.random() < 0.03) {
                        launchFirework();
                    }

                } else {
                    particles.rotation.y += (0 - particles.rotation.y) * 0.1;
                }
            }

            // Santa Animation (Random Shuttle)
            if (santaGroup) {
                // ä½¿ç”¨å¤æ‚çš„å‚æ•°æ–¹ç¨‹æ¨¡æ‹Ÿéšæœºç©¿æ¢­é£è¡Œ
                const t = time * 0.25; // é£è¡Œé€Ÿåº¦
                
                // é£è¡Œè·¯å¾„ï¼šç»“åˆæ­£å¼¦æ³¢å’Œä½™å¼¦æ³¢ï¼Œåˆ¶é€ å‡ºå›´ç»•æ ‘çš„ä¸è§„åˆ™è½¨é“
                // x: å·¦å³æ‘†åŠ¨ + å¤§å›ç¯
                const sx = Math.sin(t) * 20 + Math.cos(t * 2.3) * 8;
                // y: ä¸Šä¸‹èµ·ä¼ (é£è¡Œé«˜åº¦ 10 - 25)
                const sy = 18 + Math.cos(t * 0.7) * 5 + Math.sin(t * 3) * 2;
                // z: å‰åç©¿æ¢­ (æ·±å…¥å±å¹•å’Œå†²å‡ºå±å¹•)
                const sz = Math.cos(t) * 25 + Math.sin(t * 1.7) * 10;
                
                // è®¡ç®—ä¸‹ä¸€å¸§ä½ç½®ç”¨äºæœå‘ (lookAt)
                const tNext = t + 0.1;
                const nx = Math.sin(tNext) * 20 + Math.cos(tNext * 2.3) * 8;
                const ny = 18 + Math.cos(tNext * 0.7) * 5 + Math.sin(tNext * 3) * 2;
                const nz = Math.cos(tNext) * 25 + Math.sin(tNext * 1.7) * 10;

                santaGroup.position.set(sx, sy, sz);
                santaGroup.lookAt(nx, ny, nz);
                
                // ä¿®å¤ï¼šåˆ é™¤éšè—é€»è¾‘ï¼Œè®©åœ£è¯è€äººå§‹ç»ˆå¯è§
                // santaGroup.visible = state.morphFactor < 0.5; // å·²åˆ é™¤
            }

            // 2. Ripple Animation
            if (rippleSystem) {
                const pos = rippleSystem.geometry.attributes.position.array;
                const params = rippleSystem.userData.params;
                
                for(let i=0; i<params.length; i++) {
                    let p = params[i];
                    p.r += p.speed; 
                    if(p.r > 10) p.r = 0; 
                    
                    pos[i*3] = Math.cos(p.angle) * p.r;
                    pos[i*3+2] = Math.sin(p.angle) * p.r;
                }
                rippleSystem.geometry.attributes.position.needsUpdate = true;
            }

            // 3. Fireworks
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.age++;
                if (fw.age > fw.life) {
                    scene.remove(fw.mesh);
                    fw.mesh.geometry.dispose();
                    fireworks.splice(i, 1);
                    continue;
                }
                const positions = fw.mesh.geometry.attributes.position.array;
                for (let k = 0; k < fw.velocities.length / 3; k++) {
                    positions[k*3] += fw.velocities[k*3];
                    positions[k*3+1] += fw.velocities[k*3+1];
                    positions[k*3+2] += fw.velocities[k*3+2];
                    fw.velocities[k*3+1] -= 0.005; 
                }
                fw.mesh.geometry.attributes.position.needsUpdate = true;
                fw.mesh.material.opacity = 1 - (fw.age / fw.life);
            }

            // 4. Photo Animation Logic
            if (state.isPinching) {
                if (state.uploadedTextures.length > 0) {
                    // æœ‰ç…§ç‰‡ï¼Œæ­£å¸¸æ˜¾ç¤º
                    if (state.photoState === 'hidden' || state.photoState === 'out') {
                        state.photoState = 'in';
                        state.photoAnimProgress = 0;
                        photoMesh.visible = true;
                        updatePhotoTexture();
                        state.photoStartPos.copy(getRandomTreePos());
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        state.photoEndPos.copy(camera.position).add(camDir.multiplyScalar(10)); 
                        photoMesh.lookAt(camera.position);
                    }
                } else {
                    // æ²¡ç…§ç‰‡ï¼Œæ˜¾ç¤ºæç¤º
                    document.getElementById('photo-warning').style.display = 'block';
                }
            } else {
                // æ¾å¼€æåˆ
                document.getElementById('photo-warning').style.display = 'none';
                
                if (state.photoState === 'in' || state.photoState === 'visible') {
                    state.photoState = 'out';
                    state.photoAnimProgress = 0;
                }
            }

            const backOut = (t) => --t * t * ((1.7 + 1) * t + 1.7) + 1;

            if (state.photoState === 'in') {
                state.photoAnimProgress += 0.03; 
                if (state.photoAnimProgress >= 1) {
                    state.photoAnimProgress = 1;
                    state.photoState = 'visible';
                }
                const t = state.photoAnimProgress;
                const easeT = backOut(t); 
                
                photoMesh.position.lerpVectors(state.photoStartPos, state.photoEndPos, easeT);
                photoMesh.scale.copy(state.photoFinalScale).multiplyScalar(easeT > 1 ? 1 : easeT); 
                photoMesh.material.opacity = t; 
                photoMesh.rotation.z = (1 - easeT) * Math.PI; 
                
            } else if (state.photoState === 'out') {
                state.photoAnimProgress += 0.04;
                if (state.photoAnimProgress >= 1) {
                    state.photoAnimProgress = 1;
                    state.photoState = 'hidden';
                    photoMesh.visible = false;
                    state.currentTextureIndex = (state.currentTextureIndex + 1) % state.uploadedTextures.length;
                }
                const t = state.photoAnimProgress;
                const easeT = 1 - Math.pow(1 - t, 3);
                
                photoMesh.position.lerpVectors(state.photoEndPos, state.photoStartPos, easeT);
                photoMesh.scale.copy(state.photoFinalScale).multiplyScalar(1 - easeT);
                photoMesh.material.opacity = 1 - easeT;
                photoMesh.rotation.z = easeT * Math.PI;
            }

            if (textMesh && textMesh.visible && state.morphFactor < 0.1) {
                textMesh.position.y = 19.5 + Math.sin(time) * 0.2; 
            }

            controls.update();
            composer.render();
        }

        // --- MediaPipe & Interaction Code ---
        function setupMediaPipe() {
            const videoElement = document.querySelector('.input_video');
            const gestureText = document.getElementById('gesture-text');
            const modeText = document.getElementById('mode-text');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            hands.onResults(results => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    gestureText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹"; return;
                }
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20].map(i => landmarks[i]);
                const mcp = [5, 9, 13, 17].map(i => landmarks[i]);
                let foldedCount = 0;
                for(let i=0; i<4; i++) { if (dist(tips[i], wrist) < dist(mcp[i], wrist) * 1.2) foldedCount++; }
                if (foldedCount >= 3) {
                    state.morphTarget = 'heart'; gestureText.innerText = "âœŠ æ¡æ‹³ (çˆ±å¿ƒ)"; modeText.innerText = "çˆ±å¿ƒæ¨¡å¼";
                } else {
                    state.morphTarget = 'tree'; gestureText.innerText = "ğŸ–ï¸ å¼ æ‰‹ (åœ£è¯æ ‘)"; modeText.innerText = "åœ£è¯æ ‘æ¨¡å¼";
                }
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                if (dist(thumbTip, indexTip) < 0.05 && state.morphTarget === 'tree') {
                    state.isPinching = true; gestureText.innerText = "ğŸ‘Œ æåˆ (çœ‹ç…§ç‰‡)";
                } else { state.isPinching = false; }
                state.rotationSpeed = 0.002 + Math.abs(wrist.x - 0.5) * 0.05;
            });
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}), width: 640, height: 480
            });
            window.startCamera = () => {
                cameraUtils.start().catch(e => {
                    console.warn("æ‘„åƒå¤´ä¸å¯ç”¨", e); gestureText.innerText = "æ‘„åƒå¤´ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨é¼ æ ‡"; setupMouseFallback();
                });
            };
        }
        function dist(a, b) { return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2)); }
        function setupMouseFallback() {
            document.addEventListener('mousedown', () => { state.morphTarget = 'heart'; document.getElementById('mode-text').innerText = "çˆ±å¿ƒæ¨¡å¼ (é¼ æ ‡æŒ‰ä½)"; });
            document.addEventListener('mouseup', () => { state.morphTarget = 'tree'; document.getElementById('mode-text').innerText = "åœ£è¯æ ‘æ¨¡å¼"; });
            document.addEventListener('dblclick', () => state.isLit = true);
            document.addEventListener('keydown', (e) => { if (e.code === 'Space') state.isPinching = true; });
            document.addEventListener('keyup', (e) => { if (e.code === 'Space') state.isPinching = false; });
        }
        function setupUI() {
            const fileNameDisplay = document.getElementById('file-name');
            const photoCountDisplay = document.getElementById('photo-count-display');
            const autoLoadMsg = document.getElementById('auto-load-msg');
            const manualUploadSection = document.getElementById('manual-upload-section');
            const manualInput = document.getElementById('manual-photo-upload');
            const loader = new THREE.TextureLoader();
            
            manualInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    state.uploadedTextures = [];
                    let loadedCount = 0;
                    Array.from(e.target.files).forEach(file => {
                        const url = URL.createObjectURL(file);
                        loader.load(url, (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            state.uploadedTextures.push(tex);
                            loadedCount++;
                            fileNameDisplay.innerText = `å·²æ‰‹åŠ¨åŠ è½½ ${loadedCount} å¼ ç…§ç‰‡`;
                            photoCountDisplay.innerText = loadedCount;
                        });
                    });
                    manualUploadSection.style.display = 'none';
                    autoLoadMsg.innerText = "æ‰‹åŠ¨åŠ è½½æˆåŠŸï¼";
                    autoLoadMsg.style.color = "#00ff00";
                }
            });

            function loadLocalPhotos() {
                const photoCount = 57; 
                let loadedCount = 0;
                
                const timeoutCheck = setTimeout(() => {
                    if (loadedCount === 0) {
                        autoLoadMsg.innerText = "è‡ªåŠ¨åŠ è½½å¤±è´¥ (è¯·æ‰‹åŠ¨é€‰æ‹©)";
                        manualUploadSection.style.display = 'flex';
                    }
                }, 1000); // 1ç§’æ— å“åº”åˆ™æ˜¾ç¤ºæ‰‹åŠ¨

                for(let i=1; i<=photoCount; i++) {
                    loader.load(
                        `./photos/${i}.jpg`, 
                        (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            state.uploadedTextures.push(tex);
                            loadedCount++;
                            fileNameDisplay.innerText = `å·²è‡ªåŠ¨åŠ è½½ ${loadedCount} å¼ æœ¬åœ°ç…§ç‰‡`;
                            photoCountDisplay.innerText = loadedCount;
                            if(loadedCount === 1) {
                                clearTimeout(timeoutCheck);
                                manualUploadSection.style.display = 'none';
                                autoLoadMsg.innerText = "æ­£åœ¨è¯»å–æœ¬åœ°ç›¸å†Œ...";
                            }
                        },
                        undefined,
                        (err) => {
                        }
                    );
                }
            }

            // æ€»æ˜¯å°è¯•åŠ è½½ï¼Œå¦‚æœå¤±è´¥åˆ™è¶…æ—¶é€»è¾‘ä¼šå¤„ç†
            loadLocalPhotos();

            document.getElementById('enter-btn').addEventListener('click', () => {
                document.getElementById('start-screen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('ui-layer').style.display = 'block';
                    toggleMusic(true); if (window.startCamera) window.startCamera();
                }, 1000);
            });
            document.getElementById('light-up-btn').addEventListener('click', () => { state.isLit = true; state.lightProgress = 0; state.morphTarget = 'tree'; });
            const bgm = document.getElementById('bgm');
            const musicBtn = document.getElementById('music-toggle');
            let isMusicPlaying = false;
            function toggleMusic(forcePlay = false) {
                if (forcePlay || !isMusicPlaying) {
                    bgm.play().then(() => { isMusicPlaying = true; musicBtn.innerText = 'ğŸµ'; musicBtn.style.opacity = 1; }).catch(e => console.log("Audio play failed", e));
                } else { bgm.pause(); isMusicPlaying = false; musicBtn.innerText = 'ğŸ”‡'; musicBtn.style.opacity = 0.5; }
            }
            musicBtn.addEventListener('click', () => toggleMusic());
        }
    </script>
</body>
</html>